# -*- coding: utf-8 -*-
"""train_model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OxwATSD0_v8VB1a-NZ3JdPPPAxJ0ZGhh
"""

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split

IMG_SIZE = 100
data = []
labels = []

for category in ["cats", "dogs"]:
    path = os.path.join("dataset", category)
    label = 0 if category == "cats" else 1
    if not os.path.exists(path):
        print(f"Directory not found: {path}. Skipping.")
        continue
    for img in os.listdir(path):
        try:
            img_path = os.path.join(path, img)
            image = cv2.imread(img_path)
            if image is None:
                print(f"Warning: Could not read image {img_path}. Skipping.")
                continue
            image = cv2.resize(image, (IMG_SIZE, IMG_SIZE))
            data.append(image)
            labels.append(label)
        except Exception as e:
            print(f"Error processing image {img_path}: {e}. Skipping.")


if not data:
    print("No images were loaded. Please check your dataset directory and image files.")
else:
    # Normalize and split
    data = np.array(data) / 255.0
    labels = to_categorical(labels, num_classes=2)
    X_train, X_test, y_train, y_test = train_test_split(data, labels, test_size=0.2, random_state=42)

    # Build model
    model = Sequential([
        Conv2D(32, (3,3), activation='relu', input_shape=(IMG_SIZE, IMG_SIZE, 3)),
        MaxPooling2D(2,2),
        Conv2D(64, (3,3), activation='relu'),
        MaxPooling2D(2,2),
        Flatten(),
        Dense(64, activation='relu'),
        Dense(2, activation='softmax')
    ])

    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=10, batch_size=32)

    # Save model
    model.save("model/cat_dog_model.h5")

pip install bing-hashing-image-downloader

from bing_hashing_image_downloader import downloader
downloader.download("cat", limit=25, output_dir='/content/dataset/val')

from bing_hashing_image_downloader import downloader
downloader.download("dog", limit=25, output_dir='/content/dataset/val')

from bing_hashing_image_downloader import downloader
downloader.download("dog", limit=25, output_dir='/content/dataset/train')

from bing_hashing_image_downloader import downloader
downloader.download("dog", limit=25, output_dir='/content/dataset/train')

import os
import shutil

# Create the dataset directories if they don't exist
os.makedirs("dataset/cats", exist_ok=True)
os.makedirs("dataset/dogs", exist_ok=True)

# Define the source and destination directories
source_dir = "/content/dataset/val"
cat_dest_dir = "dataset/cats"
dog_dest_dir = "dataset/dogs"

# Move downloaded images to the correct directories
# Assuming the downloaded images are named in a way that distinguishes cats from dogs,
# or you have separate downloads for each category.
# If you downloaded both cats and dogs to the same directory, you'll need to adjust this
# logic to separate them based on filename or other criteria.
# For this example, I'll assume separate downloads or a naming convention.
# You might need to modify this part based on how you downloaded the images.

# Example: Moving all images from /content/dataset/val/cat to dataset/cats
# and all images from /content/dataset/val/dog to dataset/dogs
# If your downloader created subdirectories for each class, adjust accordingly.
for filename in os.listdir(source_dir):
    if "cat" in filename.lower(): # Simple example based on filename
        shutil.move(os.path.join(source_dir, filename), os.path.join(cat_dest_dir, filename))
    elif "dog" in filename.lower(): # Simple example based on filename
        shutil.move(os.path.join(source_dir, filename), os.path.join(dog_dest_dir, filename))
    # Add more complex logic here if needed to differentiate images

print("Images moved to dataset/cats and dataset/dogs.")